# SPDX-License-Identifier: MIT

from m1n1.ane.ane_tiler import ANETiler
from m1n1.ane.ane_utils import nextpow2

def x134_func(x):
    return x

def x138_func(x):
    return x

def x180_func(x):
    return x * 0x40

def x184_func(x):
    return x * 0x40

def x1f0_func(x):
    return x * 0x10

def x1f4_func(x):
    return x * 0x10

def x1f8_func(x):
    return x * 0x10

def x214_func(x):
    return x * 0x10

def x268_func(x):
    return x * 0x40

def x26c_func(x):
    return x * 0x40

def x20_func(x):
    if (x == 1): return 0x1024025
    if (x == 2): return 0x2024025
    if (3 <= x <= 4): return 0x3024025
    if (5 <= x <= 8): return 0x4024025
    return 0x5024025

def x15c_func(x):
    if (x == 1): return 0x4011101
    if (x == 2): return 0x4091101
    if (3 <= x <= 4): return 0x4111101
    if (5 <= x <= 8): return 0x4191101
    return 0x4211101

def x4_func(x):
    return (x//0xe1)

def relu_transform(x):
    # 1 <= x <= 0x1000
    base = [
        0x2000000, 0x0, 0x422, 0x0, 0xfff86a, 0x0, 0x30009800, 0x0,
        0x1024025, 0x0, 0xf401f800, 0x0, 0x0, 0x80, 0x80, 0x80, 0x80, 0x80,
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
        0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80,
        0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c000000, 0x10001,
        0x1, 0x22, 0x1, 0x1, 0x10001, 0x1, 0x5000a021, 0x2041, 0x14001,
        0x1, 0x0, 0x0, 0x4011101, 0x100000, 0x0, 0x6c013800, 0x33881,
        0x8880, 0x0, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x1002031, 0x0, 0x100, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x44004800, 0x0, 0x500172, 0x0, 0x10, 0x10, 0x10,
        0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x50017a, 0x10, 0x0, 0x0, 0x0, 0x0,
        0xc008800, 0x0, 0x0, 0x0, 0x0, 0x1000c800, 0x82, 0x111c0c, 0x0,
        0x0, 0x3c00, 0x18017800, 0x40000c1, 0x0, 0x40, 0x40, 0x40, 0x40,
        0x1302031
    ]
    base[0x4//4] = x4_func(x)
    base[0x20//4] = x20_func(x)
    base[0x134//4] = x134_func(x)
    base[0x138//4] = x134_func(x)
    base[0x15c//4] = x15c_func(x)
    base[0x180//4] = x180_func(x)
    base[0x184//4] = x184_func(x)
    base[0x1f0//4] = x1f0_func(x)
    base[0x1f4//4] = x1f4_func(x)
    base[0x1f8//4] = x1f8_func(x)
    base[0x214//4] = x214_func(x)
    base[0x268//4] = x268_func(x)
    base[0x26c//4] = x26c_func(x)
    return base

def linear_transform(x, alpha, beta):
    base = [0x2000000, 0x0, 0x422, 0x0, 0xfff86a, 0x0, 0x30009800, 0x0,
       0x24025, 0x0, 0xf401f800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
       0x0, 0x0, 0x3c000000, 0x10001, 0x1, 0x22, 0x8, 0x8, 0x10001, 0x1,
       0x5000a021, 0x2041, 0x10001, 0x1, 0x4, 0x0, 0x21, 0x0, 0x0,
       0x6c013800, 0x33881, 0x8880, 0x0, 0x40, 0x40, 0x200, 0x200, 0x0,
       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1002031, 0x0, 0x0, 0x0, 0x0, 0x0,
       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x44004800, 0x0, 0x500172,
       0x0, 0x10, 0x80, 0x80, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x50017a,
       0x80, 0x0, 0x0, 0x0, 0x0, 0xc008800, 0x0, 0x3c003c00, 0x3c000000,
       0x3f800000, 0x1000c800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18017800,
       0x40000c1, 0x0, 0x40, 0x40, 0x200, 0x200, 0x1302031]

    tiler = ANETiler()
    # upper
    base[0x230//4] = tiler.xV_2_yV(alpha) << 16
    # lower
    if 0:
        divisor = (nextpow2(1+1) // 2) # prev pow2
        lower_xV = beta / divisor
        # "smooths" out but i can't estimate those floats yet
        # prolly just avg step over length
        base[0x230//4] |= tiler.xV_2_yV(lower_xV)
    return base
